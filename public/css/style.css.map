{"version":3,"sources":["_webfonts.scss","style.scss","partials/_masthead.scss","modules/_colors.scss","../../../node_modules/susy/sass/susy/output/support/_rem.scss","modules/_grids.scss","../../../node_modules/susy/sass/susy/language/susy/_container.scss","../../../node_modules/susy/sass/susy/output/support/_clearfix.scss","../../../node_modules/susy/sass/susy/language/susy/_span.scss","../../../node_modules/susy/sass/susy/output/shared/_direction.scss","../../../node_modules/susy/sass/susy/language/susy/_gutters.scss","partials/_navigation.scss","partials/_content.scss","../../../node_modules/breakpoint-sass/stylesheets/_breakpoint.scss","partials/_cards.scss","../../../node_modules/susy/sass/susy/language/susy/_gallery.scss","../../../node_modules/susy/sass/susy/language/susy/_isolate.scss","../../../node_modules/susy/sass/susy/language/susy/_rows.scss","../../../node_modules/susy/sass/susy/output/float/_end.scss","partials/_footer.scss"],"names":[],"mappings":"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","file":"style.css","sourcesContent":["@import url(http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic);\n@import url(webfonts/raleway/font.css);\n@import url(webfonts/entypo/font.css);\n","@import \"webfonts\";\n@import \"normalize.css\";\n\n@import \"modules/all\";\n@import \"partials/all\";\n",".masthead {\n  $bg-color: palette(red);\n  background-color: $bg-color;\n  color: contrasting-color($bg-color, #FFF, #000);\n  a { color: inherit; }\n  .wrap { @include container; }\n  .logo { @include span(1); height: 66px; img { height: 66px; } }\n  .site-nav { @include span(11 nest last); }\n}","// http://www.ppgvoiceofcolor.com/collections/regional-collections/nova-scotia\n\n$palettes: (\n  red: (\n    base:  #777,\n    light: #CCC,\n    dark: #444\n  ),\n  blue: (\n    base:  #777,\n    light: #CCC,\n    dark: #444\n  ),\n  gray: (\n    base:  #777,\n    light: #CCC,\n    dark: #444\n  )\n);\n\n@function palette($palette, $tone: 'base') {\n    @return map-get(map-get($palettes, $palette), $tone);\n}\n","// rem Support\n// ===========\n\n// rem\n// ---\n// Check for an existing support mixin, or output directly.\n// - $prop  : <css property>\n// - $val   : <css value>\n@mixin susy-rem(\n  $prop,\n  $val\n) {\n  $_reqs: (\n    variable: rhythm-unit rem-with-px-fallback,\n    mixin: rem,\n  );\n  @if susy-support(rem, $_reqs, $warn: false) and $rhythm-unit == rem {\n    @include rem($prop, $val);\n  } @else {\n    #{$prop}: $val;\n  }\n}\n","// Requirements\n// ============\n\n@import \"susy\";\n@import \"breakpoint\";\n@import \"math\";\n\n$susy: (\n  container: 960px,\n  columns: 12\n);\n","// Container Syntax\n// ================\n\n// Container [mixin]\n// -----------------\n// Set a container element\n// - [$layout]  : <settings>\n@mixin container(\n  $layout: $susy\n) {\n  $inspect    : $layout;\n  $layout     : parse-grid($layout);\n\n  $_width     : get-container-width($layout);\n  $_justify   : parse-container-position(susy-get(container-position, $layout));\n  $_property  : if(susy-get(math, $layout) == static, width, max-width);\n\n  $_box       : susy-get(box-sizing, $layout);\n\n  @if $_box {\n    @include output((box-sizing: $_box));\n  }\n\n  @include susy-inspect(container, $inspect);\n  @include float-container($_width, $_justify, $_property);\n  @include show-grid($layout);\n}\n\n// Container [function]\n// --------------------\n// Return container width\n// - [$layout]  : <settings>\n@function container(\n  $layout: $susy\n) {\n  $layout: parse-grid($layout);\n  @return get-container-width($layout);\n}\n\n// Get Container Width\n// -------------------\n// Calculate the container width\n// - [$layout]: <settings>\n@function get-container-width(\n  $layout: $susy\n) {\n  $layout         : parse-grid($layout);\n  $_width         : susy-get(container, $layout);\n  $_column-width  : susy-get(column-width, $layout);\n  $_math          : susy-get(math, $layout);\n\n  @if not($_width) or $_width == auto {\n    @if valid-column-math($_math, $_column-width) {\n      $_columns   : susy-get(columns, $layout);\n      $_gutters   : susy-get(gutters, $layout);\n      $_spread    : if(is-split($layout), wide, narrow);\n      $_width     : susy-sum($_columns, $_gutters, $_spread) * $_column-width;\n    } @else {\n      $_width: 100%;\n    }\n  }\n\n  @return $_width;\n}\n\n// Parse Container Position\n// ------------------------\n// Parse the $container-position into margin values.\n// - [$justify]   : left | center | right | <length> [<length>]\n@function parse-container-position(\n  $justify: map-get($susy-defaults, container-position)\n) {\n  $_return: if($justify == left, 0, auto) if($justify == right, 0, auto);\n\n  @if not(index(left right center, $justify)) {\n    $_return: nth($justify, 1);\n    $_return: $_return if(length($justify) > 1, nth($justify, 2), $_return);\n  }\n\n  @return $_return;\n}\n","// Susy Fallback Clearfix\n// ======================\n\n\n// Clearfix\n// --------\n// Check for an existing support mixin, or provide a simple fallback.\n@mixin susy-clearfix {\n  @if susy-support(clearfix, (mixin: clearfix)) {\n    @include clearfix;\n  } @else {\n    &:after {\n      content: \" \";\n      display: block;\n      clear: both;\n    }\n  }\n}\n","// Span Syntax\n// ===========\n\n// Span [mixin]\n// ------------\n// Set a spanning element using shorthand syntax.\n// - $span  : <span>\n@mixin span(\n  $span\n) {\n  $inspect: $span;\n  $span: parse-span($span);\n  $output: span-math($span);\n  $nesting: susy-get(span, $span);\n  $clear: susy-get(clear, $span);\n\n  $box: susy-get(box-sizing, $span);\n  $content-box: if(susy-get(global-box-sizing) != 'border-box', true, false);\n  $box: $box or if(is-inside($span) and $content-box, border-box, null);\n\n  @if $clear == break {\n    @include break;\n  } @else if $clear == nobreak {\n    @include nobreak;\n  }\n\n  @include susy-inspect(span, $inspect);\n  @include output((box-sizing: $box));\n  @include float-span-output($output...);\n\n  @if valid-columns($nesting, silent) {\n    @include nested($span) { @content; }\n  } @else {\n    @content;\n  }\n}\n\n// Span [function]\n// ---------------\n// Return the width of a span.\n// - $span  : <span>\n@function span(\n  $span\n) {\n  @return get-span-width($span);\n}\n\n// Span Math\n// ---------\n// Get all the span results.\n// - $span: <map>\n@function span-math(\n  $span\n) {\n  $nest             : if(susy-get(role, $span) == nest, true, false);\n  $split-nest       : if(is-split($span) and $nest, true, false);\n  $edge             : get-edge($span);\n  $location         : get-location($span);\n\n  $float            : from;\n  $padding-before   : null;\n  $padding-after    : null;\n  $margin-before    : null;\n  $margin-after     : null;\n\n  // calculate widths\n  $spread: index(map-values($span), spread);\n  $span: if($split-nest and not($spread), map-merge($span, (spread: wide)), $span);\n  $width: get-span-width($span);\n  $gutters: get-gutters($span);\n\n  // apply gutters\n  @if is-inside($span) {\n    @if not(susy-get(role, $span)) {\n      $padding-before: map-get($gutters, before);\n      $padding-after: map-get($gutters, after);\n    }\n  } @else {\n    @if not($split-nest) {\n      $margin-before: map-get($gutters, before);\n      $margin-after: map-get($gutters, after);\n    }\n  }\n\n  // special margin handling\n  @if susy-get(output, $span) == isolate and $location {\n    $margin-before: get-isolation($span);\n    $margin-after: -100%;\n  } @else if $edge {\n    $is-split: is-split($span);\n    $pos: susy-get(gutter-position, $span);\n\n    @if $edge == last {\n      $float: susy-get(last-flow, $span);\n    }\n\n    @if not($is-split) {\n      @if $edge == full or ($edge == first and $pos == before) {\n        $margin-before: 0;\n      }\n      @if $edge == full or ($edge == last and $pos == after) {\n        $margin-after: 0;\n      }\n    }\n\n  }\n\n  @return (\n    width           : $width,\n    float           : $float,\n    margin-before   : $margin-before,\n    margin-after    : $margin-after,\n    padding-before  : $padding-before,\n    padding-after   : $padding-after,\n    flow            : susy-get(flow, $span),\n  );\n}\n\n// Get Span Width\n// --------------\n// Return span width.\n// - $span: <map>\n@function get-span-width(\n  $span\n) {\n  $span     : parse-span($span);\n\n  $n        : susy-get(span, $span);\n  $location : get-location($span);\n  $columns  : susy-get(columns, $span);\n  $gutters  : susy-get(gutters, $span);\n  $spread   : susy-get(spread, $span);\n\n  $context  : null;\n  $span-sum : null;\n  $width    : null;\n\n  @if $n == 'full' {\n    $pos: susy-get(gutter-position, $span);\n    $role: susy-get(role, $span);\n    $n: if($pos == split and $role != nest, susy-count($columns), 100%);\n  }\n\n  @if type-of($n) != number {\n    @warn \"(#{type-of($n)}) #{$n} is not a valid span.\";\n  } @else if unitless($n) {\n    $context: susy-sum($columns, $gutters, if(is-split($span), wide, narrow));\n    $spread: if(is-inside($span), $spread or wide, $spread);\n    $span-sum: susy($n, $location, $columns, $gutters, $spread);\n\n    $_math: susy-get(math, $span);\n    $_column-width: susy-get(column-width, $span);\n    @if $_math == static {\n      $width: $span-sum * valid-column-math($_math, $_column-width);\n    } @else {\n      $width: percentage($span-sum / $context);\n    }\n  } @else {\n    $width: $n;\n  }\n\n  @return $width;\n}\n","// Direction Helpers\n// =================\n\n// Susy Flow Defaults\n// ------------------\n// - PRIVATE\n@include susy-defaults((\n  flow: ltr,\n));\n\n// Get Direction\n// -------------\n// Return the 'from' or 'to' direction of a ltr or rtl flow.\n// - [$flow]  : ltr | rtl\n// - [$key]   : from | to\n@function get-direction(\n  $flow: map-get($susy-defaults, flow),\n  $key: from\n) {\n  $return: if($flow == rtl, (from: right, to: left), (from: left, to: right));\n  @return map-get($return, $key);\n}\n\n// To\n// --\n// Return the 'to' direction of a flow\n// - [$flow]  : ltr | rtl\n@function to(\n  $flow: map-get($susy-defaults, flow)\n) {\n  @return get-direction($flow, to);\n}\n\n// From\n// ----\n// Return the 'from' direction of a flow\n// - [$flow]  : ltr | rtl\n@function from(\n  $flow: map-get($susy-defaults, flow)\n) {\n  @return get-direction($flow, from);\n}\n","// Gutter Syntax\n// =============\n\n\n// Gutters\n// -------\n// Set gutters on an element.\n// - [$span]   : <settings>\n@mixin gutters(\n  $span: $susy\n) {\n  $inspect  : $span;\n  $span     : parse-gutters($span);\n  $_gutters : get-gutters($span);\n\n  $_output: (\n    before: map-get($_gutters, before),\n    after: map-get($_gutters, after),\n    flow: susy-get(flow, $span),\n  );\n\n  @include susy-inspect(gutters, $inspect);\n\n  @if is-inside($span) {\n    @include padding-output($_output...);\n  } @else {\n    @include margin-output($_output...);\n  }\n}\n\n@mixin gutter(\n  $span: $susy\n) {\n  @include gutters($span);\n}\n\n\n// Gutter\n// ------\n// Return the width of a gutter.\n// - [$span]   : <settings>\n@function gutter(\n  $span: $susy\n) {\n  $span: parse-gutters($span);\n\n  $_gutters: get-gutters($span);\n  $_gutters: map-get($_gutters, before) or map-get($_gutters, after);\n\n  @return $_gutters;\n}\n\n@function gutters(\n  $span: $susy\n) {\n  @return gutter($span);\n}\n\n\n// Get Gutter Width\n// ----------------\n// Return gutter width.\n// - [$context]: <context>\n@function get-gutter-width(\n  $context: $susy\n) {\n  $context  : parse-gutters($context);\n\n  $_gutters : susy-get(gutters, $context);\n  $_gutter  : susy-get(gutter-override, $context);\n\n  @if $_gutters and ($_gutters > 0) and not($_gutter) {\n    $_column-width: susy-get(column-width, $context);\n    $_math: gutter-math($context);\n    @if $_math == static {\n      $_gutter: $_gutters * valid-column-math($_math, $_column-width);\n    } @else {\n      $_columns : susy-get(columns, $context);\n      $_spread  : if(is-split($context), wide, susy-get(spread, $context));\n      $_gutter  : percentage($_gutters / susy-sum($_columns, $_gutters, $_spread));\n    }\n  }\n\n  $_gutter: if($_gutter == 'no-gutters' or $_gutter == 'no-gutter', null, $_gutter);\n\n  @return $_gutter;\n}\n\n\n// Get Gutters\n// -----------\n// Return before and after gutter values.\n// - [$context]: <context>\n@function get-gutters(\n  $context: $susy\n) {\n  $context            : parse-gutters($context);\n\n  $_gutter-position   : susy-get(gutter-position, $context);\n  $_gutter            : get-gutter-width($context);\n\n  $_return            : (before: null, after: null);\n\n  @if is-split($context) and $_gutter {\n    $_gutter: $_gutter / 2;\n    $_return: map-merge($_return, (before: $_gutter, after: $_gutter));\n  } @else {\n    $_return: map-merge($_return, ($_gutter-position: $_gutter));\n  }\n\n  @return $_return;\n}\n\n\n// Is Inside\n// ---------\n// Returns true if gutters are inside.\n// $context: <context>\n@function is-inside(\n  $context\n) {\n  $_inside: inside inside-static;\n  $_gutter-position: susy-get(gutter-position, $context);\n\n  @return if(index($_inside, $_gutter-position), true, false);\n}\n\n\n// Is Split\n// --------\n// Returns true if gutters are split.\n// $context: <context>\n@function is-split(\n  $context\n) {\n  $_split: split inside inside-static;\n  $_gutter-position: susy-get(gutter-position, $context);\n\n  @return if(index($_split, $_gutter-position), true, false);\n}\n\n\n// Gutter Math\n// -----------\n// Return the math to use for gutter calculations\n// $context: <context>\n@function gutter-math(\n  $context: $susy\n) {\n  $_return  : susy-get(math, $context);\n  $_return  : if(susy-get(gutter-position, $context) == inside-static, static, $_return);\n\n  @return $_return;\n}\n",".site-nav-toggle {\n  border: 0 none;\n  background-color: #000;\n  position: relative;\n  //display: block;\n  display: none;\n  \n  $target-size: 44px;\n  $bar-height: 2px;\n  width: $target-size;\n  height: $target-size;\n  span {\n    &, &:before, &:after {\n      display: block;\n      position: absolute;\n      width: $target-size * 0.5;\n      height: $bar-height;\n      background-color: #FFF;\n      transform: translate3d(0,0,0);\n      transition: transform 0.66s;\n    }\n    & { \n      left: ($target-size / 4);\n      top: ($target-size / 2) - ($bar-height / 2);\n    }\n    &:before, &:after { content: ' '; }\n    &:before { top: $target-size / 4.4; }\n    &:after { bottom: $target-size / 4.4; }\n  }\n  \n  // Transform into isosceles triangle\n  &:hover span {\n    &, &:before, &:after { border-radius: 2pt; }\n    &:before { transform: rotate(60deg) translate(-4px,4px); }\n    & { transform: translate(0,-7px); }\n    &:after { transform: rotate(-60deg) translate(-14px,14px); }\n  }\n}\n\n\n// TODO: Simplify navigation down to top level and single sub-level menu\n.site-nav {\n  a { text-decoration: none; }\n  ul { \n    list-style: none; \n    margin: 0; \n    padding: 0; \n  }\n  \n  // Top-level navigation\n  > ul {\n    > li { \n      display: inline-block;\n      position: relative;\n      vertical-align: top;\n      a { \n        display: block;\n        small { font-size: 8pt; display: block; color: palette(red,light); margin-top: 2pt; }\n      }\n      > a { \n        font: 300 12pt/1.2 'raleway-web', sans-serif;\n        height: 66px;\n        padding: 0 8pt;\n        color: #FFF;\n        text-transform: uppercase;\n        span { display: block; padding-top: 24px; }\n      }\n      &:hover, &:focus {\n        background-color: #FFF;\n        > a { color: palette(red); }\n      }\n      // Submenu\n      > ul { \n        display: none;\n        position: absolute;\n        top: 100%;\n        min-width: 150pt;\n        background-color: #FFF;\n        box-shadow: inset 0px 8px 15px -12px mix(palette(red), #000, 75%);\n        // Individual items\n        li a {\n          white-space: nowrap;\n          padding: 8pt;\n          color: palette(red);\n          &:hover, &:focus {\n            background-color: palette(red);\n            color: #FFF;\n          }\n        }\n      }\n      &:hover, &:focus { > ul { display: block; } }\n    }\n  }\n}","h1, h2, h3, h4, h5, h6 {\n  font-family: 'raleway-web', sans-serif;\n  font-weight: 600;\n}\n\n.wrap {\n  @include container;\n}\n\nmain > *, .mainfooter {\n  $margin-height: 18pt;\n  padding-top: $margin-height;\n  padding-bottom: $margin-height;\n  @include breakpoint(max-width susy-get(container)) {\n     padding-left: $margin-height;\n     padding-right: $margin-height;\n  }\n}\n\n.cta {\n  text-decoration: none;\n  display: inline-block;\n  padding: 6pt 8pt;\n  background-color: palette(blue);\n  color: #FFF;\n  border-radius: 3pt;\n  &:hover, &:focus { background-color: palette(blue,light); }\n  &:active { background-color: palette(blue,dark); }\n}","//////////////////////////////\n// Default Variables\n//////////////////////////////\n$Breakpoint-Settings: (\n  'default media': all,\n  'default feature': min-width,\n  'default pair': width,\n\n  'force all media type': false,\n  'to ems': false,\n  'transform resolutions': true,\n\n  'no queries': false,\n  'no query fallbacks': false,\n\n  'base font size': 16px,\n\n  'legacy syntax': false\n);\n\n$breakpoint: () !default;\n\n//////////////////////////////\n// Imports\n//////////////////////////////\n@import \"breakpoint/settings\";\n@import 'breakpoint/context';\n@import 'breakpoint/helpers';\n@import 'breakpoint/parsers';\n@import 'breakpoint/no-query';\n\n@import 'breakpoint/respond-to';\n\n@import \"breakpoint/legacy-settings\";\n\n//////////////////////////////\n// Breakpoint Mixin\n//////////////////////////////\n\n@mixin breakpoint($query, $no-query: false) {\n  @include legacy-settings-warning;\n\n  // Reset contexts\n  @include private-breakpoint-reset-contexts();\n\n  $breakpoint: breakpoint($query, false);\n\n  $query-string: map-get($breakpoint, 'query');\n  $query-fallback: map-get($breakpoint, 'fallback');\n\n  $private-breakpoint-context-holder: map-get($breakpoint, 'context holder') !global;\n  $private-breakpoint-query-count: map-get($breakpoint, 'query count') !global;\n\n  // Allow for an as-needed override or usage of no query fallback.\n  @if $no-query != false {\n    $query-fallback: $no-query;\n  }\n\n  @if $query-fallback != false {\n    $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n  }\n\n  // Print Out Query String\n  @if not breakpoint-get('no queries') {\n    @media #{$query-string} {\n      @content;\n    }\n  }\n\n  @if breakpoint-get('no query fallbacks') != false or breakpoint-get('no queries') == true {\n\n    $type: type-of(breakpoint-get('no query fallbacks'));\n    $print: false;\n\n    @if ($type == 'bool') {\n      $print: true;\n    }\n    @else if ($type == 'string') {\n      @if $query-fallback == breakpoint-get('no query fallbacks') {\n        $print: true;\n      }\n    }\n    @else if ($type == 'list') {\n      @each $wrapper in breakpoint-get('no query fallbacks') {\n        @if $query-fallback == $wrapper {\n          $print: true;\n        }\n      }\n    }\n\n    // Write Fallback\n    @if ($query-fallback != false) and ($print == true) {\n      $type-fallback: type-of($query-fallback);\n\n      @if ($type-fallback != 'bool') {\n        #{$query-fallback} & {\n          @content;\n        }\n      }\n      @else {\n        @content;\n      }\n    }\n  }\n\n  @include private-breakpoint-reset-contexts();\n}\n\n\n@mixin mq($query, $no-query: false) {\n  @include breakpoint($query, $no-query) {\n    @content;\n  }\n}\n",".cards { \n  padding-left: 0;\n  list-style: none;\n  @include container;\n  .card {\n    @include gallery(12);\n    @include breakpoint (320px) {\n      @include gallery(6);\n    }\n    @include breakpoint(820px) {\n      @include gallery(4);\n    }\n    margin-bottom: gutter();\n  }\n}\n\n$icon-square-size: 96px;\n\n.card {\n  background-color: #FFF;\n  border-radius: 2pt;\n  box-shadow: 0 2pt 4pt rgba(0,0,0,.25);\n  margin-top: ($icon-square-size / 2);\n}\n\n.card-wrap { padding: 6pt; }\n\n.card-heading {\n  text-align: center;\n  background-color: palette(blue);\n  color: contrasting-color(palette(blue), #FFF, #000);\n  margin-top: 0;\n  margin-bottom: 0;\n  padding: ($icon-square-size / 2) 6pt 6pt;\n  position: relative;\n  a { color: inherit; text-decoration: none; }\n  &-icon {\n    position: absolute;\n    width: $icon-square-size;\n    height: $icon-square-size;\n    top: -($icon-square-size / 2);\n    left: 50%;\n    margin-left: -($icon-square-size / 2);\n    border-radius: 50%;\n  }\n}","// Gallery Syntax\n// ==============\n\n// Gallery\n// -------\n// Create an isolated gallery\n// - $span        : <span>\n// - [$selector]  : child | of-type\n@mixin gallery(\n  $span,\n  $selector: child\n) {\n  $inspect    : $span;\n  $span       : parse-span($span);\n  $span       : map-merge($span, (location: 1));\n\n  $n            : susy-get(span, $span);\n  $columns      : susy-get(columns, $span);\n  $context      : susy-count($columns);\n  $flow         : susy-get(flow, $span);\n\n  $inside       : is-inside($span);\n  $from         : from($flow);\n  $line         : floor($context / $n);\n  $symmetrical  : is-symmetrical($columns);\n\n  $output: (\n    width             : null,\n    float             : from,\n    margin-before     : null,\n    margin-after      : null,\n    padding-before    : null,\n    padding-after     : null,\n    flow              : $flow,\n  );\n\n  @if $inside {\n    $gutters: get-gutters($span);\n    $output: map-merge($output, (\n      padding-before: map-get($gutters, before),\n      padding-after: map-get($gutters, after),\n    ));\n  }\n\n  @if $symmetrical {\n    $output: map-merge($output, (width: get-span-width($span)));\n  }\n\n  $box          : susy-get(box-sizing, $span);\n  $global-box   : if(susy-get(global-box-sizing) == 'border-box', true, false);\n\n  @include susy-inspect(gallery, $inspect);\n\n  // Collective Output\n  @if $box == border-box or ($inside and not($box) and not($global-box)) {\n    @include output((box-sizing: border-box));\n  } @else if $box == content-box {\n    @include output((box-sizing: content-box));\n  }\n\n  @include float-span-output($output...);\n\n  // Individual Loop\n  @for $item from 1 through $line {\n    $nth: '#{$line}n + #{$item}';\n    &:nth-#{$selector}(#{$nth}) {\n      // Individual Prep\n      $output: (\n        width             : if($symmetrical, null, get-span-width($span)),\n        float             : null,\n        margin-before     : get-isolation($span),\n        margin-after      : -100%,\n        padding-before    : null,\n        padding-after     : null,\n        flow              : $flow,\n      );\n\n      // Individual Output\n      @include float-span-output($output...);\n\n      @if get-edge($span) == first {\n        @include break;\n        @include first($span);\n      } @else {\n        @include nobreak;\n      }\n\n      // Individual Location Increment\n      $location: get-location($span) + $n;\n      $location: if($location > $context, 1, $location);\n      $span: map-merge($span, (location: $location));\n    }\n  }\n}\n","// Isolation Syntax\n// ================\n\n\n// Isolate [Mixin]\n// ---------------\n// Set isolation as an override.\n// - $location: <span>\n@mixin isolate(\n  $isolate: 1\n) {\n  $inspect: $isolate;\n\n  $output: (\n    push: isolate($isolate),\n    flow: susy-get(flow, $isolate),\n  );\n\n  @include susy-inspect(isolate, $inspect);\n  @include isolate-output($output...);\n}\n\n\n// Isolate [function]\n// ------------------\n// Return an isolation offset width.\n// - $location: <span>\n@function isolate(\n  $isolate: 1\n) {\n  $isolate: parse-span($isolate);\n  $isolation: susy-get(span, $isolate);\n\n  @if $isolation and not(get-location($isolate)) {\n    $new: (\n      span: null,\n      location: $isolation,\n    );\n    $isolate: map-merge($isolate, $new);\n  }\n\n  @return get-isolation($isolate);\n}\n\n\n// Get Isolation\n// -------------\n// Return the isolation offset width\n// - $input: <map>\n@function get-isolation(\n  $input\n) {\n  $location   : get-location($input);\n  $columns    : susy-get(columns, $input);\n  $width      : null;\n\n  @if type-of($location) == number and not(unitless($location)) {\n    $width: $location;\n  } @else if $location {\n    $push: $location - 1;\n    @if $push > 0 {\n      $push: map-merge($input, (\n        span: $push,\n        location: 1,\n        spread: wide,\n      ));\n      $width: get-span-width($push);\n    }\n  }\n\n  @if susy-get(gutter-position, $input) == split {\n    $width: if($width == null, gutters($input), $width + gutters($input));\n  }\n\n  @return $width or 0;\n}\n","// Row Start & End\n// ===============\n\n// Break\n// -----\n// Apply to any element that should force a line break.\n@mixin break {\n  @include output((clear: both));\n}\n\n\n// NoBreak\n// -------\n// Cancel the break() effect, e.g. when using media queries.\n@mixin nobreak {\n  @include output((clear: none));\n}\n\n\n// Full\n// ----\n// - [$context]: <layout shorthand>\n@mixin full(\n  $context: $susy\n) {\n  $inspect : $context;\n  @include susy-inspect(full, $inspect);\n  @include span(full of parse-grid($context) break);\n}\n\n\n// First\n// -----\n// - [$context]: <settings>\n@mixin first(\n  $context: $susy\n) {\n  $inspect  : $context;\n  $context  : parse-grid($context);\n  $flow     : susy-get(flow, $context);\n\n  @include susy-inspect(first, $inspect);\n  @if not(is-split($context)) {\n    @include float-first($flow);\n  }\n}\n\n@mixin alpha(\n  $context: $susy\n) {\n  @include first($context);\n}\n\n\n// Last\n// ----\n// - [$context]: <settings>\n@mixin last(\n  $context: $susy\n) {\n  $inspect  : $context;\n  $context  : parse-grid($context);\n\n  @include susy-inspect(last, $inspect);\n\n  $output: (\n    flow: susy-get(flow, $context),\n    last-flow: susy-get(last-flow, $context),\n    margin: if(is-split($context), null, 0),\n  );\n\n  @include float-last($output...);\n}\n\n@mixin omega(\n  $context: $susy\n) {\n  @include last($context);\n}\n\n\n// Get Edge\n// --------\n// Calculate edge value based on location, if possible\n@function get-edge(\n  $span\n) {\n  $span       : parse-span($span);\n  $edge       : susy-get(edge, $span);\n\n  @if not($edge) {\n    $count: susy-count(susy-get(columns, $span));\n    $location: susy-get(location, $span);\n    $n: susy-get(span, $span);\n\n    $number: if(type-of($location) == number, true, false);\n    $index: if($number and unitless($location), true, false);\n\n    @if $n == $count {\n      $edge: full;\n    } @else if $location and $n and $index {\n      @if $location == 1 {\n        $edge: if($n == $count, full, first);\n      } @else if $location + $n - 1 == $count {\n        $edge: last;\n      }\n    }\n  }\n\n  @if $edge == alpha or $edge == omega {\n    $edge: if($edge == alpha, first, last);\n  }\n\n  @return $edge;\n}\n\n\n// Get Location\n// ------------\n// Calculate location value based on edge, if possible\n@function get-location(\n  $span\n) {\n  $span       : parse-span($span);\n  $location   : susy-get(location, $span);\n  $edge       : get-edge($span);\n  $n          : susy-get(span, $span);\n\n  @if $edge and not($location) and type-of($n) == number and unitless($n) {\n    @if $edge == first {\n      $location: 1;\n    } @else if $edge == last {\n      $location: susy-count(susy-get(columns, $span)) - $n + 1;\n    }\n  }\n\n  @return $location\n}\n","// Float Ends API\n// ==============\n\n// Susy End Defaults\n// -----------------\n// - PRIVATE\n@include susy-defaults((\n  last-flow: to,\n));\n\n// Float Last\n// ----------\n// - [$flow]  : ltr | rtl\n@mixin float-last(\n  $flow: map-get($susy-defaults, flow),\n  $last-flow: map-get($susy-defaults, last-flow),\n  $margin: 0\n) {\n  $to: to($flow);\n\n  $output: (\n    float: if($last-flow == to, $to, null),\n    margin-#{$to}: $margin,\n  );\n\n  @include output($output);\n}\n\n// Float First\n// -----------\n// - [$flow]  : ltr | rtl\n@mixin float-first(\n  $flow: map-get($susy-defaults, flow)\n) {\n  $output: (\n    margin-#{from($flow)}: 0,\n  );\n\n  @include output($output);\n}\n",".mainfooter {\n  $bg-color: palette(blue);\n  background-color: $bg-color;\n  color: contrasting-color($bg-color, #FFF, #000);\n  a { color: inherit; }\n\n  .logo { \n    @include span(2);\n    img { max-width: 100%; }\n  }\n\n  .cr { \n    @include span(10 last);\n    p { margin: 0; font-size: 10pt; }\n    p:first-of-type { \n      font: 14pt 'raleway-web', serif;\n      text-transform: uppercase;\n    }\n  }\n\n  @include breakpoint(321px) {\n    .logo { @include span(1); }\n    .cr { @include span(11 last); }\n  }\n}\n\n"],"sourceRoot":"/source/"}